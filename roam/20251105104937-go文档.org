o* 入口函数与包初始化：搞清go程序执行顺序 :ATTACH:
<2025-11-02 Sun>

*
const (
	c1 = "c1"
	c2 = "c2"
)
((with-temp-file "~/.emacs.d/.local/cache/org/test.txt" (insert "test")))
var (
	_  = contsInitCheck()
	v1 = variableInit("v1")
	v2 = variableInit("v2")
)

func init() {
	fmt.Println("init 第一次被调用")
}

func init() {
	fmt.Println("init 第二次被调用")
}

(message "%s" org-roam-db-location)


(with-temp-file "~/.emacs.d/.local/cache/org/test.txt" (insert "test"))


func variableInit(name string) string {
	fmt.Println("main:", name, "被初始化")
	return name
}

func contsInitCheck() string {
	if c1 != "" {
		fmt.Println("main:c1已经被初始化,c1=", c1)
	}
	if c2 != "" {
		fmt.Println("main:c2已经被初始化,c2=", c2)
	}
	return ""
}

func main() {

}

#+END_SRC
=结果=
#+begin_src
pkg3:c1已经被初始化,c1= c1
pkg3:c2已经被初始化,c2= c2
pkg3: v1 被初始化
pkg3: v2 被初始化
init 第一次被调用
init 第二次被调用
pkg1:c1已经被初始化,c1= c1
pkg1:c2已经被初始化,c2= c2
pkg1: v1 被初始化
pkg1: v2 被初始化
pkg1:init 第一次被调用
pkg1:init 第二次被调用
pkg2:c1已经被初始化,c1= c1
pkg2:c2已经被初始化,c2= c2
pkg2: v1 被初始化
pkg2: v2 被初始化
pkg2:init 第一次被调用
pkg2:init 第二次被调用
main:c1已经被初始化,c1= c1
main:c2已经被初始化,c2= c2
main: v1 被初始化
main: v2 被初始化
init 第一次被调用
init 第二次被调用
#+end_src


**  init函数用途


#+begin_src go
package main

import (
	"flag"
	"fmt"
	"os"
)

var CommandLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)

func init() {
	CommandLine.Usage = customUsage
}

func customUsage() {
	fmt.Fprintf(CommandLine.Output(), "%s-应用程序\n\n", os.Args[0])
	fmt.Fprintf(CommandLine.Output(), "选项:")
	CommandLine.PrintDefaults()
	fmt.Fprintf(CommandLine.Output(), "\n使用实例:")
	fmt.Fprintf(CommandLine.Output(), " %s -name=Bob\n", os.Args[0])
	fmt.Fprintf(CommandLine.Output(), "%s -help\n", os.Args[0])
}

func main() {
	name := CommandLine.String("name", "world", "指向问候的名称")
	CommandLine.Parse(os.Args[1:])
	fmt.Printf("hello,%s\n", *name)
}
#+end_src
=重置包级变量=

#+begin_src go
var (
    http2VerboseLogs    bool // 初始化时默认值为false
    http2logFrameWrites bool // 初始化时默认值为false
    http2logFrameReads  bool // 初始化时默认值为false
    http2inTests        bool // 初始化时默认值为false
)

func init() {
    e := os.Getenv("GODEBUG")
    if strings.Contains(e, "http2debug=1") {
        http2VerboseLogs = true // 在init中对http2VerboseLogs的值进行重置
    }
    if strings.Contains(e, "http2debug=2") {
        http2VerboseLogs = true // 在init中对http2VerboseLogs的值进行重置
        http2logFrameWrites = true // 在init中对http2logFrameWrites的值进行重置
        http2logFrameReads = true // 在init中对http2logFrameReads的值进行重置
    }
}
#+end_src
=根据环境变量GODEBUG的值，对包级开关变量进行了复杂的初始化，从而保证这些开关变量在http包初始化结束后，可以处理合理状态.

#+begin_src go
import (
    "database/sql"
    _ "github.com/lib/pq"
)

func main() {
    db, err := sql.Open("postgres", "user=pqgotest dbname=pqgotest sslmode=verify-full")
    if err != nil {
        log.Fatal(err)
    }

    age := 21
    rows, err := db.Query("SELECT name FROM users WHERE age = $1", age)
    ...
}

#+end_src

 #+begin_src go
func init() {
    sql.Register("postgres", &Driver{})
}

 #+end_src

=注册模式=
空导入/lib/pq产生一个副作用，会把postgres驱动注册进去.这种在init函数中注册自己的实现方式，有效降低了包对外的直接暴露，尤其是包级变了的暴露。


#+begin_src go

package main

import (
    "fmt"
    "image"
    _ "image/gif" // 以空导入方式注入gif图片格式驱动
    _ "image/jpeg" // 以空导入方式注入jpeg图片格式驱动
    _ "image/png" // 以空导入方式注入png图片格式驱动
    "os"
)

func main() {
    // 支持png, jpeg, gif
    width, height, err := imageSize(os.Args[1]) // 获取传入的图片文件的宽与高
    if err != nil {
        fmt.Println("get image size error:", err)
        return
    }
    fmt.Printf("image size: [%d, %d]\n", width, height)
}

func imageSize(imageFile string) (int, int, error) {
    f, _ := os.Open(imageFile) // 打开图文文件
    defer f.Close()

    img, _, err := image.Decode(f) // 对文件进行解码，得到图片实例
    if err != nil {
        return 0, 0, err
    }

    b := img.Bounds() // 返回图片区域
    return b.Max.X, b.Max.Y, nil
}
#+end_src

#+begin_src go
// $GOROOT/src/image/png/reader.go
func init() {
    image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
}

// $GOROOT/src/image/jpeg/reader.go
func init() {
    image.RegisterFormat("jpeg", "\xff\xd8", Decode, DecodeConfig)
}

// $GOROOT/src/image/gif/reader.go
func init() {
    image.RegisterFormat("gif", "GIF8?a", Decode, DecodeConfig)
}

#+end_src


=大多go程序都是并发程序，程序会启动多个goroutine并发执行程序逻辑，一定要主要goroutine优雅退出，也就是住goroutine要根据实际情况来决定，是否要等待其他goroutine子线程做完收尾工作后再退出.=

** 习题
1. 同一个包内有多个源文件的话，这个包是将所有源文件的常量、变量、init() 函数汇集到一起，然后常量-变量-init() 这样的顺序进行初始化，而不是每个源文件走一遍常量-变量-init() 这样的顺序，是嘛？老师
   作者回复: 问题很好。实测情况是go会先按文件传入顺序，分别初始化常量与变量，然后在分别调用各个文件中的init函数。比如说如果一个pkg1有两个文件file1.go和file2.go，那么初始化顺序是：file1中的常量 -> file1中的变量 -> file2中常量 -> file2中变量 -> file1中init函数 -> file2中init函数。
2.
    - Go 包的初始化次序：
   1）依赖包按“深度优先”的次序进行初始化；
   2）每个包内按以“常量 -> 变量 -> init 函数”（main.main 函数前）的顺序进行初始化；
   3）包内的多个 init 函数按出现次序进行自动调用。
   4）如果一个包内有多个文件，则按照file1:常量、变量 file2:常量、变量.fiel1:init file2:init
    - init 函数常见用途：
   1）重置包级变量值；
   2）实现对包级变量的复杂初始化；
   3）在 init 函数中实现“注册模式”（工厂设计模式）- 空导入。
   - init 函数具备的几种行为特征（init 函数十分适合做一些包级数据初始化工作以及包级数据初始状态的检查工作）：
   1）执行顺位排在包内其他语法元素的后面；
   2）每个 init 函数在整个 Go 程序生命周期内仅会被执行一次；
   3）init 函数是顺序执行的，只有当一个 init 函数执行完毕后，才会去执行下一个 init 函数。
 3.
    =初始化 init 函数先于 main 函数执行，项目中如非必要，禁止隐式的 init 初始化，协作人员多了，各种千奇百怪的问题都可能导致程序执行失败。转而使用显式的初始化，直接在 main 函数中调用对应的初始化方法=
 4.
   init失败的话，我感觉一般init中要完成的内容好像都偏向资源属性，如果有必然能成功的默认属性则走默认值并警告，如果是必要资源则不成功会影响后续的运行，这时候应该要直接严重错误告警并终止程序吧
 5.
 日常实践中，我会将不同类型的初始化操作放在不同init（初始化的“内聚”），同一包内的不同文件的内的初始化，都放在各自文件中，这样代码可读性好一些。
