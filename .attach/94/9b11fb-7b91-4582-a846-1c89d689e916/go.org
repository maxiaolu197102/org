#+titlOAOAOAe: Go

* 第一章 这样如何go，才能少走弯路
**   导图
*** go的吸引力
1. 语法简单
2. 支持内存垃圾回收
3. 原生支持并发
4. 生产力与性能最佳结合，适用云开发、中间件、云服务等
*** 学习方法
1. 心定
2. 手勤
3. 脑勤
*** go的设计意识
go接口与goroutine等并发原语类型有一个共同的特点，就是可以影响到go的应用程序的结构和
设计的语法元素.
核心思想：定义了程序的结构和沟通方式
-  接口定义了建筑的蓝图和标准(比如每个房间都要有门窗)。它决定了组件如何组合在一起.
- goroutine和chanel定义了建筑内人员和物资的流动方式(电梯、走廊、传送带)，它决定了
   组件如何协作.
1. 接口塑造程序的静态结构：从实现是什么到能做什么的转变
   - 没有接口的时候，你关注的是具体类型(MysqlConnection)
   - 有了接口，你关注的是(DbConnector接口的Query方法)，这让你从实现细节中抽离，思考
     更高层次的抽象.
#+BEGIN_SRC go
func WriteData(w io.Write, data []byte)error{
	_,err := w.Write()
	return err
}
#+END_SRC
writeData可以满足任何io.Write的方法：文件，http响应、缓冲区、字节流等.因为它依赖一个接口，而非具体实现.
在OA微服务和大型应用中，会为关键组件(数据库层、缓存层、外部api调用)定义接口，清晰划分了程序的边界，是协作、测试和替换实现(比如从本地缓存切换到redis)变得非常容易
总结：接口定义了行为契约，塑造了代码的组件划分、依赖关系和模块化架构，使得程序变得松耦合和高内聚，易于测试.
goroutine和channel影响的是程序的执行流和数据流，这是一种运行时的动态的结构设计.
- 从顺序执行到并行执行：没有并发原语，程序都是线性的故事线。
- chanel是并发体之间的胶水，不仅传递数据，更重要的是传递控制信号和同步上下文。
两者的结合：塑造完整的应用程序架构
一个设计良好的 Go 程序，通常是这两种结构的完美结合：
宏观上，用接口划分模块：你的系统被划分为 UserService、OrderRepository、PaymentGateway 等接口，它们定义了系统的功能和边界。
微观上，用并发原语实现模块：在 UserService 的具体实现内部，可能会启动多个 Goroutine 通过 Channel 协作来处理用户请求、批量写入日志或执行定时清理任务。
举例：一个网络服务
接口层面：你定义了 Handler 接口，这使得任何具有 ServeHTTP方法的类型都可以处理请求。这是静态的、可替换的结构。
并发层面：Go 的 net/http 库会为每个传入的请求启动一个 Goroutine 来执行你的Handler。这是动态的、并发的结构。你的程序天然就是一个高效的并发服务器，这种“一个连接一个Goroutine”的模式深刻影响了你在 Handler 中处理状态和进行IO操作的方式。
结论
接口决定了你的代码“是什么”以及 =如何组合= ，它塑造了程序的骨骼。
Goroutine 和 Channel 决定了你的代码“如何运行”以及“如何沟通”，它塑造了程序的神经和血管。
这正是“影响应用程序结构设计”的含义——它们不是孤立的语法特性，而是构建复杂、可维护、高性能 Go 应用程序的核心设计模式与哲学基础。当你开始用 Go 设计系统时，你实际上就是在用接口和并发原语这两种“乐高积木”来搭建整个世界的蓝图。


* 第二章 前生今世，你不得不了解go的历史和现状
** 罗伯特发的初创go思路的邮件
日期：2007年9月23日 23:33:41 -0700
发件人："Robert Griesemer" <gri@google.com>
收件人："Rob 'Commander' Pike" <r@google.com>, ken@google.com
主题：编程语言讨论

...
*** 总体方向：
起点：以C语言为基础，修复一些明显缺陷，移除冗余内容，添加一些缺失的功能
- 没有头文件包含，改用：import导入
- 没有宏（是否需要替代方案？）--"我们应该提供机制而不是策略。宏是一种策略，而函数、接口、泛型是机制。"
- 理想情况下只需一个文件，而不是.h和.c文件，模块接口应能自动提取
- 语句：类似C语言，但应修复'switch'语句
- 表达式：类似C语言，但有些注意事项（是否需要','表达式？）
- 本质上是强类型语言，但可能支持运行时类型
- 需要始终进行数组边界检查（也许除了"不安全模式"——参见垃圾回收章节）
- 提供连接垃圾回收的机制（我认为大多数代码可以使用GC，但真正的系统编程语言应提供完全控制内存分配的模式）
- 支持接口（区分具体类型/实现类型与抽象类型/接口类型）
  | 类型分类 | 定义                             | 关注点                             |
  | 具体类型 | 具有完整结构定义的类型           | 是什么，它有什么字段，占用多少内存 |
  | 实现类型 | 定义了某个接口的具体类型         | 实现了哪个接口                     |
  | 抽象类型 | 一个设计概念，定义了行为而非实现 | 应该做什么，定义了职责和契约       |
  | 接口类型 | 一组方法的签名集合               | 契约是什么，必须实现哪些方法       |
核心思想：
设计的时候，定义的是抽象类型(接口类型)，来规划模块之间的协作关系
实现的时候，创建具体类型(实现类型)，来提供具体功能
运行的时候，使用抽象类型来引用具体类型，从而实现程序的灵活和扩展性
-  支持嵌套函数和匿名函数/闭包（若不使用则不产生开销）
- 简单编译器应能生成优质代码
- 各种语言机制应产生可预测的代码

 go技术发展曲线
1.5开始进入膨胀期(gc延迟大幅度优化)，1.6到1.9达到了峰值。 1.11发布前跌到了底谷。1.11引入了go module,又开始缓慢爬升。1.18版本开始支持泛型

* 第三章 go设计哲学

** 导读
1. 简单:做减法、去繁从简
2. 显式: 不允许不同类型进行混合运算、基于值比较得错误处理方案
3. 组合:类型嵌入和接口
4. 并发:采用了用户级轻量线程goroutine
5. 面向工程: 解决大规模软件开发存在的问题.


** 简单
1. 25个关键字
2. 垃圾回收
3. 首字母大写决定可见性
4. 变量初始为类型零值，避免随机值作为初值得问题
5. 内置数组越界检查
6. 内置支持并发
7. 内置接口类型，为组合得设计哲学奠定基础
8. 原生提供完整得工具链。
简单的设计哲学是go生产力的源泉

** 显式
1. 显式转换
#+BEGIN_SRC go :results output
import "fmt"
func main(){
	a := int8(10)
	b := int16(20)
	c := int32(30)
	e := int64(a)+int64(b)+int64(c)
	fmt.Println("e:=",e)
}
#+END_SRC
#+RESULTS:
: e:= 60
 2. 基于显示的值比较的错误处理方案，函数/方法中错误都通过return语句显式返回，并且调用者不能忽略对错误的处理.
3. 组合
   - 正交的语法元素
     * 无类型层次体系，各类型之间是独立的，没有子类型的概念
     * 每个类型都可以有自己的方法集合，类型定义和方法实现是正交的
     * 实现某个接口，无需特定的修饰词
     * 包之间是独立的，没有子包的概念
一座座没有关联的孤岛，但是每个岛内又很精彩。将这些孤岛用最适当的方式建立关联，并形成一个整体。而go采用的组合方式，也是最主要的方式.
组合原则实质上是塑造了go程序的骨架结构。类型嵌入提供了垂直扩展能力，而接口是水平组合的关键，给与连接关节两个部分各自自由活动的能力。整体上又是是实现了某种功能，并且，组合也体现了简单的go原则。

4. 并发
   多核，原生支持并发作为设计原则之一。采用了用户级轻量线程。goroutine.
   channel和select并发原语.可以通过channel传递消息或者实现同步，通过select实现多路channel并发控制。
   并发与组合的哲学是一脉相承的。并发是更大一个组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面：goroutines各自执行特定的工作，通过channel+select将groutines组合连接起来。并发的存在鼓励程序员在程序上设计进行独立计算的分解。
5. 面向工程
   1. 源码快速编译
   2. 源码导入不使用的包，无法编译。保证程序构建的时候不会编译额外的代码。
   3. 去掉包的循环依赖
   4. 包路径是唯一的，包名可以不必唯一
   5. 不支持默认函数参数
   6. 增加类型别名，支持大规模代码库重构

* 第四章  配好环境：选择一种最适合你的go安装方法

1. go版本发布策略
每年二月和八月发布两次大版本。对目前最新稳定的两个大版本提供支持.


* 第五章 一个go程序结构是怎样的
 1. goplus
    * 同一生态，终结碎片化
      在gopls之前，每个编辑器需要各自实现go的代码补全，跳转等功能，导致：
      1.功能不一致，体验碎片化
      2.重复造轮子，资源浪费
      3.新特性推广慢
gopls提供了标准化的语言智能协议，让所有编辑器都能通过一套接口获得一致的go开发体验
 2. 性能和高并发解决方案
    1.  增量编译和缓存策略
       * 多层缓存结构
       * 之冲洗分析变更的文件
    2. 懒加载和按需计算
       * 启动的时候，只建立基础索引
       * 用户操作时，按需深入分析
       * 渐进式构建完整模型
 3. 并发架构设计
    * 严格的并发控制
    * 使用对象池减少gc压力
 4. 工作窃取与负载均衡
    * 每个工作线程有自己的队列
    * 从其他工作线程来窃取任务进行负载均衡
** 第一个go程序
#+BEGIN_SRC go :results output
import "fmt" //fmt是路径名
func main(){
	fmt.Println("hello,world\n") //fmt是包名
}
#+END_SRC

#+RESULTS:
: hello,world

go源文件是采用unicode字符集，用的是utf-8的字符编码方式.

** 如何强制生成纯静态程序
这段这段内容解释了 Go 语言编译时的 动态链接与静态链接 行为，核心与 CGO_ENABLED 环境变量及标准库实现方式有关。具体可以拆解为以下几点：
1. CGO_ENABLED 的默认状态
Go 默认开启 CGO_ENABLED=1，即允许程序使用 CGO 特性（调用 C 语言代码、链接 C 库等）。
这一开关决定了 Go 编译器在链接阶段如何选择标准库中某些功能的实现。
2. 标准库的「双实现」设计
Go 标准库中，部分功能（如网络、系统调用相关）存在 两份实现：
C 语言实现：依赖系统的 C 动态链接库（如 libc），兼容性更好，但会导致编译出的程序依赖外部动态库。
Go 语言纯实现：不依赖任何 C 库，完全用 Go 代码实现，编译后可生成纯静态程序（不依赖外部动态库）。
3. 编译结果为何有差异？
案例 1：简单程序（如 hello world）不涉及依赖 C 实现的功能（如网络、复杂系统调用），无论 CGO_ENABLED 是 1 还是 0，编译结果都是 纯静态程序（无动态链接）。
案例 2：使用 http 包的 Web 服务http 包底层依赖网络相关功能，当 CGO_ENABLED=1 时，Go 会优先选择 C 语言实现，导致编译出的程序 动态链接系统的 C 库（如 libpthread、libc 等）。此时用 ldd 命令查看二进制文件，会看到依赖的动态库。
4. 如何强制生成纯静态程序？
若将 CGO_ENABLED 设为 0（export CGO_ENABLED=0），Go 编译器会强制使用 纯 Go 实现 的标准库功能，此时编译出的程序 不依赖任何动态库，是完全静态的二进制文件。
例如：
bash
=CGO_ENABLED=0 go build -o myapp main.go=
用 ldd myapp 查看会显示「不是动态可执行文件」。
总结
CGO_ENABLED 控制 Go 标准库中「C 实现」和「纯 Go 实现」的选择。
动态链接与否，取决于程序是否用到了依赖 C 实现的功能，以及 CGO_ENABLED 的值。
若需跨平台分发（避免目标系统缺失动态库），通常会用 CGO_ENABLED=0 编译纯静态程序。



* 第六章 标准先行 go项目的布局标准是什么
1. 放在项目顶层的go modul相关文件，包括go.mod go.sum
2. cmd: 存放项目要编译构建的可执行文件对应main包的源码文件
3. 项目包目录：每个目录对应一个go包
4. internal目录：存在项目内部引用的go包，在项目之外无法引用
5. vendor：可选目录


* 第七章 构建模式：go是怎么解决包依赖管理问题的

1. 一个go modules是一个go包的集合。modelue是有版本号的。所以modules下的包也就有了版本属性。这个module与这些包组成一个独立的版本单元，他们一起打版本，发布和分发。
   一个代码仓库对应一个go modules.一个go modules项目下会放置一个go.mod,每个go.mod定义一个module.
   go.mod文件所在的顶层目录也成为module根目录。module根目录及它的子目录下所有的包都属于这个go moudle，这个module成为main modlue.

* 第八章 go module 6类常规操作

  go mod vendor创建vendor模式，用于在内部一些持续集成或者持续交付的环境(ci/cd).
  如果基于vendor构建，而不是基本本地缓存的go modeule构建，需要在go build加上-mod=vendor参数.

1. import _ "foo"
空导入也是导入，意味着我们将依赖foo这个路径下的包。但由于是空导入，我们并没有显式使用这个包中的任何语法元素。那么空导入的意义是什么呢？由于依赖foo包，程序初始化的时候会沿着包的依赖链初始化foo包，我们在08里会讲到包的初始化会按照常量->变量->init函数的次序进行。通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。
问题2：
通常我们直接使用go module(非vendor)模式即可满足大部分需求。如果是那种开发环境受限，因无法访问外部代理而无法通过go命令自动解决依赖和下载依赖的环境下，我们通过vendor来辅助解决。

2. 为什么我删除了依赖包后，GOMODCACHE中 pkg/mod 中还存在这个包，这个里面是只能手动去删除的吗?
作者回复: GOMODCACHE中 pkg/mod 中的缓存包是你的用户下所有go项目共享的。单独在一个go项目中删除对其依赖只是删除了go.mod中的记录。依赖在用户下的缓存不会被删除。要删除缓存，目前只能整体删除，用go clean -modcache 命令

* 第九章 入口函数与包初始化：搞清go的执行顺序 :ATTACH:
:PROPERTIES:
:ID:       949b11fb-7b91-4582-a846-1c89d689e916
:END:
[[attachment:_20251101_215242screenshot.png]]


*  faq
**  gc延迟较大
在 Go 语言中：
GC 工作原理：Go 的垃圾回收器会定期扫描内存，找出不再使用的对象并释放它们。
STW（Stop-The-World）：为了准确标记哪些内存还在使用，GC 在某个阶段需要暂停所有 Goroutine。这个暂停时间就是主要的 GC 延迟。
延迟的表现：
1. 网络请求处理突然变慢
2. 实时数据处理出现间隙
具体数字示例
go
// 假设一个高内存分配的程序
func processData() {
    data := make([]byte, 100*1024*1024) // 分配100MB
    // ...处理数据...
    // 函数结束，这100MB成为垃圾
}
如果频繁调用这样的函数：
GC 压力大：需要回收大量内存
延迟可能从 1ms 增加到 10ms+
对于要求 1ms 响应的系统，10ms 就是“较大延迟”

*  go的并发原语
** 同步原语(控制协程执行顺序)
用于协调多个线程的执行节奏，确保错误的有序性
1. sync.WaitGroup :
   - 功能:等待一组协程完成(阻塞当前携程、知道所有子携程结束)
   - 方法:Add(n)注册要等待的协程数量、Done(标记一个协程完成)、Wait(等待所有协程完成)
   - 场景:批量启动工作协程后，主流程等待所有工作完成再继续
2. sync.Once
   - 功能:保证代码只执行一次(无论多少协程调用)
   - 方法:Do(f func()):传入要执行一次的函数
   - 场景:单例初始化、配置加载需要懒加载并且仅仅加载一次的逻辑
3. sync.Cond
   - 功能:基于条件变量的协程唤醒机制(让协程等待某个条件成立后再执行)
   - 方法：Wait()等待条件、Signal()(唤醒一个等待协程)、BrOADCAST()(唤醒所有等待协程)
   - 场景:生产者、消费者模型中，消费者等待队列非空时唤醒
** 互斥原语(保护共享资源)
用于防止多个协程同时操作共享资源，避免数据竞争
1. sync.Mutex
   - 功能:互斥锁，确保同一事件只有一个写成能够获得锁
   - 方法:Lock()(加锁)、Unlock(解锁)
   - 注意:未加锁掉哟个unlock会抛出异常，需要配合defer使用
   - 场景:所有需要独占访问共享资源的场景(修改全局变量、操作共享缓存)
2. sync.RWMutex
   - 功能:读写锁:区分读操作和写操作，执行多协程同时读、单写操作独占
   - 方法:Rlock/RUnlock、Lock\Unlock
   - 场景:读多写少的场景(读取配置、缓存查询)，提供并发读性能
3. sync.Map
   - 功能:并发安全哈希表(专门为协程安全设计的map)
   - 方法:Load(key) Store(key,value) Delete(key) Range(f)
   - 场景:需要在多个协程中频繁读写键值对，替代map+Mutex的组合

** 原子操作(sync/atomic)
用户对基本数据类型(int32 uint64等)进行不可分割的操作，避免数据竞争(比锁更轻量)
1. 数值操作
   - AddInt32/AddUnit64:原子增减
   - LoadInt32/StoreInt64: 原子读写(确保内存可见性)
   - SwapInt32 :原子交换(写入新值、替换旧值)
2. 比较操作(cas)
   - ompareandswapint32(addr,old,new):当addr的值等于old，原子更新为new
3. 布尔与指针操作
   - atomic.Bool:原子bool类型(Load()/Store())
   - atoimic.Poniter[T]:原子指针(安全在协程间传递指针)
   - 场景:计数器、状态标记 无锁数据结构
4. 通道
   go特有的通信原语，通过消息传递实现协程间同步，而非共享内存。
   - 无缓冲通道(chan T)：发送<-和接收会互相阻塞，直到对方准备好
   - 有缓冲通道(chan T 初始化指定容量)
   - 缓冲区未满时发送不阻塞，缓冲区未空时接收不阻塞(异步通信)


** 其他辅助原子操作(sync/atomic)
1. context.Context
   - 功能: 跟踪协程生命周期、传递取消信息、超时时间和请求元素据
